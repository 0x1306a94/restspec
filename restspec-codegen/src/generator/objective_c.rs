#![allow(dead_code)]
#![allow(unused_variables)]

use super::generator::{GeneratedCode, Generator};
use tree_sitter::Node;

use lazy_static::*;
use std::sync::Mutex;

use std::collections::HashMap;

use crate::{kind, option};

enum AssociationPolicy {
    Assign,
    RetainNonAtomic,
    CopyNonAtomic,
    Retain,
    Copy,
}

impl ToString for AssociationPolicy {
    fn to_string(&self) -> String {
        match &self {
            AssociationPolicy::Assign => "nonatomic, assign".to_owned(),
            AssociationPolicy::RetainNonAtomic => "nonatomic, strong".to_owned(),
            AssociationPolicy::CopyNonAtomic => "nonatomic, copy".to_owned(),
            AssociationPolicy::Retain => "atomic, strong".to_owned(),
            AssociationPolicy::Copy => "atomic, copy".to_owned(),
        }
    }
}

struct PropertyInfo(String, AssociationPolicy, bool);
struct CustomTypeInfo(AssociationPolicy, bool);

const GENERATE_HEAD_CODE: &str = "
//
// Code generated by https://github.com/0x1306a94/restspec
//


";
lazy_static! {
    static ref STANDARD_TYPE_MAP: HashMap<String, PropertyInfo> = {
        let mut map = HashMap::new();
        map.insert(
            "Bool".to_owned(),
            PropertyInfo("BOOL".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "String".to_owned(),
            PropertyInfo(
                "NSString".to_owned(),
                AssociationPolicy::CopyNonAtomic,
                true,
            ),
        );
        map.insert(
            "Map".to_owned(),
            PropertyInfo(
                "NSDictionary".to_owned(),
                AssociationPolicy::CopyNonAtomic,
                true,
            ),
        );
        map.insert(
            "Array".to_owned(),
            PropertyInfo("NSArray".to_owned(), AssociationPolicy::CopyNonAtomic, true),
        );
        map.insert(
            "Double".to_owned(),
            PropertyInfo("double".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "Float".to_owned(),
            PropertyInfo("float".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "Int".to_owned(),
            PropertyInfo("NSInteger".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "Int8".to_owned(),
            PropertyInfo("int8_t".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "Int16".to_owned(),
            PropertyInfo("int16_t".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "Int32".to_owned(),
            PropertyInfo("int32_t".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "Int64".to_owned(),
            PropertyInfo("int64_t".to_owned(), AssociationPolicy::Assign, false),
        );

        map.insert(
            "UInt".to_owned(),
            PropertyInfo("NSUInteger".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "UInt8".to_owned(),
            PropertyInfo("uint8_t".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "UInt16".to_owned(),
            PropertyInfo("uint16_t".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "UInt32".to_owned(),
            PropertyInfo("uint32_t".to_owned(), AssociationPolicy::Assign, false),
        );
        map.insert(
            "UInt64".to_owned(),
            PropertyInfo("uint64_t".to_owned(), AssociationPolicy::Assign, false),
        );
        map
    };
    static ref CUSTOM_TYPE_MAP: Mutex<HashMap<String, CustomTypeInfo>> = {
        let map = HashMap::new();
        Mutex::new(map)
    };
}

pub struct ObjectiveCGenerator {}

impl ObjectiveCGenerator {
    pub fn new() -> Self {
        ObjectiveCGenerator {}
    }
}

impl Generator for ObjectiveCGenerator {
    fn generate_enum_code(
        &self,
        source_code: &str,
        node: &Node,
        option_cache: &option::cache::Cache,
    ) -> Result<Vec<GeneratedCode>, String> {
        let enum_name = node
            .child(1)
            .expect("Failed to get child node")
            .utf8_text(source_code.as_bytes())
            .expect("fail text");

        let enum_name = option_cache
            .get(option::key::OBJECTIVE_C_PREFIX)
            .map_or(enum_name.to_string(), |v| v.replace('"', "") + enum_name);

        let mut generated_code = String::new();
        generated_code.push_str(GENERATE_HEAD_CODE);
        generated_code.push_str(&format!("#ifndef {enum_name}_h\n"));
        generated_code.push_str(&format!("#define {enum_name}_h\n\n"));
        generated_code.push_str("#import <Foundation/Foundation.h>\n\n");

        match extract_comment(source_code, node) {
            Some(comment) => {
                generated_code.push_str(comment);
                generated_code.push_str("\n");
            }
            _ => {}
        }
        generated_code.push_str(&format!("typedef NS_ENUM(NSInteger, {enum_name}) {{\n"));
        if node.child_count() >= 5 {
            for idx in 3..(node.child_count() - 1) {
                let case_node = node.child(idx).expect("fail case node");
                if case_node.kind() == kind::COMMENT {
                    continue;
                }
                let case_name = case_node
                    .child(0)
                    .expect("fail case name node")
                    .utf8_text(source_code.as_bytes())
                    .expect("fail get text");

                match extract_comment(source_code, &case_node) {
                    Some(comment) => {
                        generated_code.push_str("\t");
                        generated_code.push_str(comment);
                        generated_code.push_str("\n");
                    }
                    _ => {}
                }

                match case_node.child_count() {
                    4 => {
                        let case_value = case_node
                            .child(2)
                            .expect("fail case value node")
                            .utf8_text(source_code.as_bytes())
                            .expect("fail get text");
                        generated_code += &format!("\t{enum_name}{case_name} = {case_value},\n");
                    }
                    _ => {
                        generated_code += &format!("\t{enum_name}{case_name} = 0,\n");
                    }
                }
            }
        }
        generated_code += "};\n\n";
        generated_code.push_str(&format!("#endif /* {enum_name}_h */\n"));

        CUSTOM_TYPE_MAP.lock().unwrap().insert(
            enum_name.to_string(),
            CustomTypeInfo(AssociationPolicy::Assign, false),
        );
        Ok(vec![GeneratedCode::new(
            &format!("{enum_name}.h"),
            &generated_code,
        )])
    }

    fn generate_enum_options_code(
        &self,
        source_code: &str,
        node: &Node,
        option_cache: &option::cache::Cache,
    ) -> Result<Vec<GeneratedCode>, String> {
        let enum_name = node
            .child(1)
            .expect("Failed to get child node")
            .utf8_text(source_code.as_bytes())
            .expect("fail text");

        let enum_name = option_cache
            .get(option::key::OBJECTIVE_C_PREFIX)
            .map_or(enum_name.to_string(), |v| v.replace('"', "") + enum_name);

        let mut generated_code = String::new();
        generated_code.push_str(GENERATE_HEAD_CODE);
        generated_code.push_str(&format!("#ifndef {enum_name}_h\n"));
        generated_code.push_str(&format!("#define {enum_name}_h\n\n"));
        generated_code.push_str("#import <Foundation/Foundation.h>\n\n");

        match extract_comment(source_code, node) {
            Some(comment) => {
                generated_code.push_str(comment);
                generated_code.push_str("\n");
            }
            _ => {}
        }

        generated_code.push_str(&format!(
            "typedef NS_OPTIONS(NSUInteger, {}) {{\n",
            enum_name
        ));
        if node.child_count() >= 5 {
            for idx in 3..(node.child_count() - 1) {
                let case_node = node.child(idx).expect("fail case node");
                if case_node.kind() == kind::COMMENT {
                    continue;
                }
                let case_name = case_node
                    .child(0)
                    .expect("fail case name node")
                    .utf8_text(source_code.as_bytes())
                    .expect("fail get text");

                match extract_comment(source_code, &case_node) {
                    Some(comment) => {
                        generated_code.push_str("\t");
                        generated_code.push_str(comment);
                        generated_code.push_str("\n");
                    }
                    _ => {}
                }

                match case_node.child_count() {
                    4 => {
                        let case_value = case_node
                            .child(2)
                            .expect("fail case value node")
                            .utf8_text(source_code.as_bytes())
                            .expect("fail get text");
                        generated_code += &format!("\t{enum_name}{case_name} = {case_value},\n");
                    }
                    6 => {
                        let base_value = case_node
                            .child(2)
                            .expect("fail case base value node")
                            .utf8_text(source_code.as_bytes())
                            .expect("fail get text");

                        let shift_value = case_node
                            .child(4)
                            .expect("fail case shift value node")
                            .utf8_text(source_code.as_bytes())
                            .expect("fail get text");
                        generated_code +=
                            &format!("\t{enum_name}{case_name} = {base_value} << {shift_value},\n");
                    }
                    _ => {
                        generated_code += &format!("\t{enum_name}{case_name} = 0,\n");
                    }
                }
            }
        }
        generated_code += "};\n\n";
        generated_code.push_str(&format!("#endif /* {enum_name}_h */\n"));

        CUSTOM_TYPE_MAP.lock().unwrap().insert(
            enum_name.to_string(),
            CustomTypeInfo(AssociationPolicy::Assign, false),
        );

        Ok(vec![GeneratedCode::new(
            &format!("{enum_name}.h"),
            &generated_code,
        )])
    }

    fn generate_class_code(
        &self,
        source_code: &str,
        node: &Node,
        option_cache: &option::cache::Cache,
    ) -> Result<Vec<GeneratedCode>, String> {
        let class_name = node
            .child(1)
            .expect("Failed to get child node")
            .utf8_text(source_code.as_bytes())
            .expect("fail text");

        let class_name = option_cache
            .get(option::key::OBJECTIVE_C_PREFIX)
            .map_or(class_name.to_string(), |v| v.replace('"', "") + class_name);

        let mut generated_code = String::new();
        generated_code.push_str(GENERATE_HEAD_CODE);
        generated_code.push_str(&format!("#ifndef {class_name}_h\n"));
        generated_code.push_str(&format!("#define {class_name}_h\n\n"));
        generated_code.push_str("#import <Foundation/Foundation.h>\n\n");

        let mut forward_declaration_code = String::new();

        let mut interface_code = String::new();

        if node.child_count() >= 5 {
            match extract_comment(source_code, node) {
                Some(comment) => {
                    interface_code.push_str(comment);
                    interface_code.push_str("\n");
                }
                _ => {}
            }
            let super_class_name = "NSObject";
            interface_code.push_str(&format!("@interface {class_name} : {super_class_name}\n"));

            for idx in 3..(node.child_count() - 1) {
                let field_node = node.child(idx).expect("fail get filed node");
                if field_node.kind() == kind::COMMENT {
                    continue;
                }

                let type_idx: usize = 0;
                let name_idx: usize = match field_node.child_count() {
                    4 => 2,
                    _ => 1,
                };
                let optional = name_idx == 2;

                let type_name = field_node
                    .child(type_idx)
                    .expect("fail type node")
                    .utf8_text(source_code.as_bytes())
                    .expect("text");

                let field_name = field_node
                    .child(name_idx)
                    .expect("fail type node")
                    .utf8_text(source_code.as_bytes())
                    .expect("text");

                match extract_comment(source_code, &field_node) {
                    Some(comment) => {
                        interface_code.push_str(comment);
                        interface_code.push_str("\n");
                    }
                    _ => {}
                }

                match (*STANDARD_TYPE_MAP).get(type_name) {
                    Some(value) => {
                        let mut optional_code = String::new();
                        if value.2 && optional {
                            optional_code.push_str(", nullable");
                        }
                        let type_name = match value.1 {
                            AssociationPolicy::Assign => format!("{} ", value.0),
                            _ => format!("{} *", value.0),
                        };
                        interface_code.push_str(&format!(
                            "@property ({}{optional_code}) {type_name}{field_name};\n",
                            value.1.to_string()
                        ));
                    }
                    None => {
                        let type_name = option_cache
                            .get(option::key::OBJECTIVE_C_PREFIX)
                            .map_or(type_name.to_string(), |v| v.replace('"', "") + type_name);
                        match CUSTOM_TYPE_MAP.lock().unwrap().get(&type_name) {
                            Some(value) => {
                                let mut optional_code = String::new();
                                if value.1 && optional {
                                    optional_code.push_str(", nullable");
                                }

                                let final_type = match value.0 {
                                    AssociationPolicy::Assign => {
                                        generated_code
                                            .push_str(&format!("#import \"{type_name}.h\"\n"));
                                        format!("{type_name} ")
                                    }
                                    _ => {
                                        forward_declaration_code
                                            .push_str(&format!("@class {type_name};\n"));
                                        format!("{type_name} *")
                                    }
                                };

                                interface_code.push_str(&format!(
                                    "@property ({}{optional_code}) {final_type}{field_name};\n",
                                    value.0.to_string()
                                ));
                            }
                            None => {
                                panic!("Type {type_name} not found");
                            }
                        }
                    }
                }
            }

            interface_code.push_str("@end\n");
        }

        generated_code.push_str("\nNS_ASSUME_NONNULL_BEGIN\n\n");

        if !forward_declaration_code.is_empty() {
            generated_code += &forward_declaration_code;
            generated_code += "\n";
        }
        generated_code += &interface_code;

        generated_code += "\nNS_ASSUME_NONNULL_END\n\n";
        generated_code.push_str(&format!("#endif /* {}_h */\n", class_name));

        CUSTOM_TYPE_MAP.lock().unwrap().insert(
            class_name.to_string(),
            CustomTypeInfo(AssociationPolicy::RetainNonAtomic, true),
        );

        let mut implementation_code = String::new();
        implementation_code.push_str(GENERATE_HEAD_CODE);
        implementation_code.push_str(&format!("#import \"{}.h\"\n\n", class_name));
        implementation_code.push_str(&format!("@implementation {}\n\n", class_name));
        implementation_code.push_str("@end\n\n");
        Ok(vec![
            GeneratedCode::new(&format!("{}.h", class_name), &generated_code),
            GeneratedCode::new(&format!("{}.m", class_name), &implementation_code),
        ])
    }
}

fn extract_comment<'a>(source_code: &'a str, node: &Node) -> Option<&'a str> {
    let sibling = node.prev_sibling()?;
    if sibling.kind() != kind::COMMENT {
        return None;
    }

    match sibling.utf8_text(source_code.as_bytes()) {
        Ok(comment) => Some(comment),
        _ => None,
    }
}
